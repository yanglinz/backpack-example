package docker

import (
	"io/ioutil"
	"path/filepath"
	"strings"

	"github.com/goccy/go-yaml"
	"github.com/yanglinz/backpack/internal"
	"github.com/yanglinz/backpack/symbols"
)

var composeHeader = `# @backpack
# This is an autogenerated docker-compose file.
# It is not meant to be hand-edited.

`

type composeConfigRequest struct {
	target string
}

type composeBuild struct {
	Context    string `yaml:"context"`
	Dockerfile string `yaml:"dockerfile"`
}

type composeService struct {
	Image       string       `yaml:"image,omitempty"`
	Build       composeBuild `yaml:"build,omitempty"`
	Entrypoint  string       `yaml:"entrypoint,omitempty"`
	Command     string       `yaml:"command,omitempty"`
	Environment []string     `yaml:"environment,omitempty"`
	Ports       []string     `yaml:"ports,omitempty"`
	Volumes     []string     `yaml:"volumes,omitempty"`
	DependsOn   []string     `yaml:"depends_on,omitempty"`
}

// ComposeConfig is a struct of the standard docker-compose.yml config
type ComposeConfig struct {
	Version  string                 `yaml:"version"`
	Services map[string]interface{} `yaml:"services"`
}

func getStartCommand(bashCommands []string) string {
	return "bash -c \"" + strings.Join(bashCommands, " \\\n && ") + "\""
}

func getDependentServices(backpack internal.Context, req composeConfigRequest) map[string]interface{} {
	services := make(map[string]interface{})

	// Add postgres to services
	if backpack.Services.Postgres {
		service := composeService{
			Image: "postgres:11.6",
			Environment: []string{
				"POSTGRES_DB=postgres",
				"POSTGRES_PASSWORD=postgres",
				"POSTGRES_USER=postgres",
			},
			Ports:   []string{"5432:5432"},
			Volumes: []string{"./var/postgres:/var/lib/postgresql/data"},
		}
		services["postgres"] = service
	}

	// Add redis to services
	if backpack.Services.Redis {
		service := composeService{
			Image: "redis:5.0.5",
		}
		services["redis"] = service
	}

	return services
}

func getServerService(backpack internal.Context, project internal.Project, req composeConfigRequest) (string, composeService) {
	dockerfile := ".backpack/docker/python-dev.Dockerfile"
	if req.target == symbols.EnvProduction {
		dockerfile = ".backpack/docker/python-prod.Dockerfile"
	}
	build := composeBuild{
		Context:    ".",
		Dockerfile: dockerfile,
	}

	startCommand := ".backpack/runtime/entry-dev.sh"
	if req.target == symbols.EnvProduction {
		startCommand = ".backpack/runtime/entry-prod.sh"
	}
	commands := []string{startCommand}
	if backpack.Services.Postgres {
		commands = []string{
			".backpack/docker/scripts/wait-for-it.sh -t 60 postgres:5432",
			".backpack/docker/scripts/wait-for-pg.sh",
			"sleep 2",
			startCommand,
		}
	}

	ports := []string{"8000:8000", "8080:8080"}
	volumes := []string{
		".:/app/",
		"/app/node_modules",
		"$HOME/.config/gcloud:/home/app/.config/gcloud",
	}

	djangoSettingsModule := filepath.Join(project.Path, "settings")
	djangoSettingsModule = strings.ReplaceAll(djangoSettingsModule, "/", ".")
	environment := []string{
		"DJANGO_SETTINGS_MODULE=" + djangoSettingsModule,
		// Set a custom local dev only env var to help applications
		// Distinguish whether they're running locally or in GCP
		"BACKPACK_DOCKER_COMPOSE=true",
	}
	if req.target == symbols.EnvProduction {
		// Set PORT so just like Heroku and Cloudrun environments
		environment = append(environment, "PORT=8080")
	}

	dependsOn := []string{}
	if backpack.Services.Postgres {
		dependsOn = append(dependsOn, "postgres")
	}
	if backpack.Services.Redis {
		dependsOn = append(dependsOn, "redis")
	}

	service := composeService{
		Build:       build,
		Command:     getStartCommand(commands),
		Ports:       ports,
		Volumes:     volumes,
		Environment: environment,
		DependsOn:   dependsOn,
	}

	serviceName := project.Name + "_server"
	return serviceName, service
}

func getServerServices(backpack internal.Context, req composeConfigRequest) map[string]interface{} {
	services := make(map[string]interface{})

	// Add server services
	for _, p := range backpack.Projects {
		serviceName, service := getServerService(backpack, p, req)
		services[serviceName] = service
	}

	return services
}

// GetComposeConfig creates a yaml map of docker-compose.yml
func GetComposeConfig(backpack internal.Context, req composeConfigRequest) ComposeConfig {
	services := make(map[string]interface{})

	// Get dependent services
	dependentServices := getDependentServices(backpack, req)
	for k, v := range dependentServices {
		services[k] = v
	}

	// Get server services
	serverServices := getServerServices(backpack, req)
	for k, v := range serverServices {
		services[k] = v
	}

	// Generate config
	composeConfig := ComposeConfig{
		Version:  "3.6",
		Services: services,
	}
	return composeConfig
}

// CreateComposeConfig creates the project docker-compose.yml
func CreateComposeConfig(backpack internal.Context) {
	defaultConfig := GetComposeConfig(backpack, composeConfigRequest{
		target: symbols.EnvDevelopment,
	})
	configYaml, _ := yaml.Marshal(defaultConfig)
	content := strings.Join([]string{composeHeader, string(configYaml)}, "")

	composePath := filepath.Join(backpack.Root, "docker-compose.yml")
	err := ioutil.WriteFile(composePath, []byte(content), 0644)
	if err != nil {
		panic(err)
	}

	prodConfig := GetComposeConfig(backpack, composeConfigRequest{
		target: symbols.EnvProduction,
	})
	configYaml, _ = yaml.Marshal(prodConfig)
	content = strings.Join([]string{composeHeader, string(configYaml)}, "")

	composePath = filepath.Join(backpack.Root, "docker-compose-prod.yml")
	err = ioutil.WriteFile(composePath, []byte(content), 0644)
	if err != nil {
		panic(err)
	}
}
